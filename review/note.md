### Euler - 10

> 两百万以内素数的和到了十四位，已经超了32位整型最大值10位

### Euler - 11

> 虽然设置了比矩阵大５的数组，但是依然四个方向上访问时可能出现越界访问

### !

> 核心已转储，要么因为越界，要么因为爆了

### Euler - 14

> 一定看清楚题目要求求得是相应数字，不是循环节长度

### 注意

> 注意看题目中给的提醒，此外也要思考特殊情况

### Euler - 32

> 题目中讲１　～　９没有０，因此初始化时要将０赋值为１，表示已经标记过，每一处都要思考对不对，不要盲目忽略，以防出错

### Euler - 35

> 检查发现出现了疏忽的错误，把`circular`的判断变量写成了`i`，应该是`prime[i]`
>
> 总结出现问题的种类：疏忽错误，逻辑错误。现在先检查疏忽错误，以后写代码过程中要看着自己写的代码，防止出现这种错误，提高效率

### Euler - 37

> 本题没有找到估算上界方法时发现，边界条件是个数１１个
>
> 与其判断是不是质数，不如直接从线性筛中一个一个拿，活学活用，毕竟质数已经都拿出来了
>
> 注意`is_prime[0]` 和　`is_prime[1]` 要设为１，防止判断到个位数时把其当做质数

### `pow`浮点数结果导致的错误

```c
// 错误示范
int h = log10(x);
tmp = x;
while (tmp) {
	if (is_prime[tmp]) return 0;
    tmp -= tmp / pow(10, h) * pow(10, h); // 运算过程中变成了浮点数，所以导致tmp得０，需要强制转换
    h--;																		// pow运算结果是浮点数，使得过程中运算变成了浮点数运算
}
```

```c
// 正确
int h = pow(10, floor(log10(x)));　// 这时已经将浮点数转换为整型了
tmp = x;
while (tmp) {
    if (is_prime[tmp]) return 0;
    tmp -= tmp / h * h;
    h /= 10;
}
```

### 提升找`bug`的能力

> 找ｂｕｇ的能力是随着刷题多了才能提升的，一些需要注意的点是在刷题时发现的
>
> 想和做是不一样的，只有打出来才能发现问题

> 找bug把代码过程打出来，比如求和结果不对，把每一个加数结果打出来看是不是爆了

###　Euler - 38

> 有时候，把两个问题合起来麻烦，一步步来简单
>
> 先加再判断有没有重复１－９比先判断再加简单
>
> 合起来判断一次，比分起来判断简单，而且逻辑也简单
>
> 思维不能固化，学会的技巧要搞清楚什么时候才有使用的必要，不要一股脑先入为主，不要只是为了用套路，反而把别的简单问题变麻烦

### Euler - 43

> 理解好题意，如果首位是０，那么数字整体就是不含有０的了，不符合条件，注意类似题目

### Euler - 44

> 此题无法直接确定枚举上界，但是可以在过程中判断什么时候没有枚举必要
>
> 始终无法出答案，陷入了死循环，没有了逻辑问题，原因是给的整型太小爆掉了，要注意了

### Euler - 45

> 经过题目数据验证逻辑没有问题，但还是无缘无故陷入死循环，证明是因为整型爆掉

### Euler - 12

> 眼高手低容易出错，比如因子个数，不是素数筛加一下就可以的，这只能算出素因子个数，真正的因子个数还要考虑素因子幂次的问题
>
> 结果不对，不是因为爆掉了，是因为开的数组太小，居然有结果，当然是错的。这个错的结果不是找到的，也不是因为爆掉，而是循环最后一个`i`被当做了找到的`i`

### Euler - 13

> 大整数加法时，必须把位数初始化为1`ans[0]=1`否则加不上新的值，进入不了位数的循环

### Euler - 15

> 把过程中的ans打出来看，结果是在做了优化的情况下还是爆了，因为用的int，改成long long就好了，因为毕竟做了优化。本来就担心爆，上来就应该开long long不管做没做优化

```c
while (ans % j == 0) ans /= j, j++; 
// 这样写不对，因为最后j到20的时候可能多除21/22/等等，要考虑对j的限制失效
```

```c
if (ans % j == 0) ans /= j, j++; // 只能这么写
```

### Euler - 16

> 大整数乘法，不仅位数要初始化位1，而且第一位个位也要初始化为1，否则最后乘法结果是0

### Euler - 18

> 千万注意输入循环第二层`j <= i`等于号，否则每一行都会少输入一个