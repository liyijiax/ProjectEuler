### Euler - 10

> 两百万以内素数的和到了十四位，已经超了32位整型最大值10位

### Euler - 11

> 虽然设置了比矩阵大５的数组，但是依然四个方向上访问时可能出现越界访问

### !

> 核心已转储，要么因为越界，要么因为爆了

### Euler - 14

> 一定看清楚题目要求求得是相应数字，不是循环节长度

### 注意

> 注意看题目中给的提醒，此外也要思考特殊情况

### Euler - 32

> 题目中讲１　～　９没有０，因此初始化时要将０赋值为１，表示已经标记过，每一处都要思考对不对，不要盲目忽略，以防出错

### Euler - 35

> 检查发现出现了疏忽的错误，把`circular`的判断变量写成了`i`，应该是`prime[i]`
>
> 总结出现问题的种类：疏忽错误，逻辑错误。现在先检查疏忽错误，以后写代码过程中要看着自己写的代码，防止出现这种错误，提高效率

### Euler - 37

> 本题没有找到估算上界方法时发现，边界条件是个数１１个
>
> 与其判断是不是质数，不如直接从线性筛中一个一个拿，活学活用，毕竟质数已经都拿出来了
>
> 注意`is_prime[0]` 和　`is_prime[1]` 要设为１，防止判断到个位数时把其当做质数

### `pow`浮点数结果导致的错误

```c
// 错误示范
int h = log10(x);
tmp = x;
while (tmp) {
	if (is_prime[tmp]) return 0;
    tmp -= tmp / pow(10, h) * pow(10, h); // 运算过程中变成了浮点数，所以导致tmp得０，需要强制转换
    h--;																		// pow运算结果是浮点数，使得过程中运算变成了浮点数运算
}
```

```c
// 正确
int h = pow(10, floor(log10(x)));　// 这时已经将浮点数转换为整型了
tmp = x;
while (tmp) {
    if (is_prime[tmp]) return 0;
    tmp -= tmp / h * h;
    h /= 10;
}
```

### 提升找`bug`的能力

> 找ｂｕｇ的能力是随着刷题多了才能提升的，一些需要注意的点是在刷题时发现的
>
> 想和做是不一样的，只有打出来才能发现问题