#### 最大公约数证明

* 问题结果不能流失
* 要保证最大性

#### 标记数组

* 需要估算数组大小，从而确定初始大小
* 外层`O(N)`总体`O(N) * log(log(N))`
* 标记次数太多

#### 素数筛

> 素数筛就是根据每一个素数，往后进行标记合数，没有标记的就是素数

####　线性筛

> 线性筛一方面不限制于只有素数才能参与标记，另一方面限制了标记的次数，真正的实现了Ｏ(N)
>
> 把每一个遍历到的数字当做最大因子，然后配合下来，这样每一个合数就只会被标记一次
>
> 如果使用最小因子，那么这时还不知道比它大的素数有谁，所以不能使用最小因子
>
> 线性筛同时也把筛选出来的素数放在标记数组的前flag[0]个位置，配合遍历到的最大因子
>
> 总之，一般情况下，都只是用比当前数小的，已知的来标记未知的

#### Euler-8

> 用某种数据结构存起来
>
> 放在文件中
>
> 重定向

* `INT64_MAX` 以二开头的大概１９位数字
* 用什么数组：字符数组
* 对于字符串，使用`for`循环时，可以用`num[i]`作为终止条件，只要不是\0就不终止

**注意可能超过整型范围**

* `ctrl + v` 接下来　`shift + i`  然后按两下`ESC`,右边按列复制粘贴

#### 方向数组(Euler-11)

> 几维　以及　几个方向
>
> x 控制数组行数，ｙ控制数组列数
>
> 输入重定向 `./a.out < input`
>
> > 方向数组在搜索中是很经典的
> >
> > 如果不用这个，递归搜索可能导致信转储，递归层数太多,系统栈最大８ＭＢ
> >
> > 头递归、尾递归。逆向递归，for 循环，即用方向数组来做
> >
> > 搜索算法看看。百度查资料，自学搜索算法。深搜广搜。
> >
> > 数独、迷宫问题、最少走几步等等

#### Euler-14

* 暴力做法：
  * 段错误可能`int`保存不下，有明显延迟
* 记忆化搜索：
  * 数组过大，反而变慢了
  * `cache`中级数越多，缓存大小越大，时间越慢，想要命中想要的数据效率变低了

#### Euler-17

* `static` 每次调用这个函数，不用再次初始化，只初始化一次
* `const`不能更改

> 尾递归使用for循环去写，减少栈爆的问题，减少函数调用，减少时间上的开销
>
> `inline`内联函数，可能成功可能失败，成功调用时减少开销，会调用前展开

#### Euler-13

* 如果是整形数组的话恐怕难以读入，只能使用字符数组对于这些大整数问题
* 还可以做大数乘法、减法、除法问题

#### Euler-31

>  递推问题：三步走
>
>  * 赋予合理语义信息
>  * 确立动态递归dp方程
>
>  不能重复、或者用容斥定理

* 出现负数：
  * 越界
  * 表示不下

> 算法中的`dp`问题，动态规划问题，最难得也就六十行代码，难的是逻辑，是你想不到怎么转化动态转移方程
>
> 感觉
>
> `10000 * 10000` 的二维数组就开不下了，三维的也开不出来，或者浪费，降维

* 搜索、递推、`dp`

**多做点`dp`问题**

#### Euler-32

* 枚举要有一个上界
* `inline`gcc不能用 得加上动态链接库 `-fgnu89-inline`

#### Euler-33

* pow结果是浮点型

#### Euler-37

> 没有给边界的题首先怎么估计边界也很重要

* 发现结果是30个，要求是11个时，需要做的就是把得到的数字打出来，找出不合格的，结果发现有的包含1，原因就是，没有这种双数组的标记方法，没有把1排除出素数，标记的时候直接从2开始的，因此把1标记为合数排除此原因。
* 之外可以看到多出的数字中也有个位数，计算位数，不把这些个位数加入即可。
* 此外笔算的时候如果1在中间不需要排除，因为有些多位质数是包含数字1的！

> 耽误时间的原因在于：没有调用`init()`而是把原来没有封装的代码留在了主函数中
>
> > 其次，就是注意把结果打出来，把过程中一部分打出来，有助于`debug`
> >
> > 注意封装提高`debug`速度
> >
> > 逻辑上一定要严密，每一步都要思考，不要一笔带过，这样容易出错，特别是在那些觉得理所当然的地方，比如本题中的`is_val`中的`for`的边界条件，一般这时就是那些并不是太理所当然的东西，就要思考了，并不是平时写了很多遍的，而是有一些变化的，不一样的东西，就要思考

